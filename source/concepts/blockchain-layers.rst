.. -- Conditionals Genesis / Apla -------------------------------------------------

.. backend GitHub repo name and link
.. |backend_gh| replace:: `go-genesis`_
.. _go-genesis: https://github.com/GenesisKernel/go-genesis 
.. .. |backend_gh| replace:: `go-apla`_
.. .. _go-apla: https://github.com/AplaProject/go-apla


.. frontend GitHub repo name and link
.. |frontend_gh| replace:: `genesis-front`_
.. _genesis-front: https://github.com/GenesisKernel/genesis-front   
.. .. |frontend_gh| replace:: `apla-front`_
.. .. _apla-front: https://github.com/AplaProject/apla-front 



About |platform| blockchain
###########################

This section explains how |platform| works with blockchain. 


Tip of the iceberg
==================

If you are interested in developing |platform| apps, using them, or managing ecosystems, then you probably don't need to know anything about the |platform| blockchain at all.

In |platform|, the blockchain and the blockchain network are hidden from ecosystem members, administrators, and even app developers. Instead, |platform| provides interfaces for all these groups of users. These interfaces provide access to the top layer of a blockchain: its tamper-proof distributed *global state*. 


App developers
--------------

In technical terms, the *global state* is a set of data. |platform|'s implementation of its global state is a database. Applications written by app developers interact with this database in a usual way: by querying, inserting, and updating the database tables. 

|platform| applications are a collection of contracts and pages that interact with tables. Under the hood, contracts are converted into transactions, validated, and written to the blockchain. This leads to changes in the global state, the database. For an app developer, however, a contract is a function. When it is executed, data is written to the database. A page is also a set of functions. Some of them display page elements, other fetch data from the database. No knowledge of transactions, block generation or consensus algorithms is required from an application developer to work with |platform| blockchain.


Ecosystem members
-----------------

Ecosystem members are regular users of |platform|. They interact with the *global state* via apps written by app developers.

Regular users can view and modify the database from application pages, like they would do in a common web application: by filling forms, pressing buttons, and navigating pages.


Some of these apps are *platform apps*, which are provided by |platform| developers. Platform apps are included in every ecosystem. They provide core functionality for managing ecosystems. Examples include apps that create new accounts, allow voting for ecosystem parameter changes, and allow token transfer between accounts.

Other apps are *ecosystem apps*, that implement some certain functionality or business process specific to an ecosystem. Examples include apps for supply chain and accounting, banking, trading, and governance institutions.


Under the hood
==============


The layers
----------

Under the top layer that is visible to ecosystem members and app developers, lies the "engine" of |platform|, its node network and blockchain protocols.

You can think of |platform| as having several layers: 

    - User interfaces layer

        Ecosystem members interact with applications via pages and page elements.

    - Apps layer

        App developers interact with global state (database tables) via contract and page code.

    - Global state layer

        Global state (database) is updated and synchronized based on the operations written to the distributed ledger of operations (blockchain).

    - Blockchain layer

        Distributed ledger of operations is updated with new blocks. New blocks hold the operations (transactions) that must be performed on the global state.

    - Node network layer

        Network nodes implement |platform| blockchain protocol. They distribute transactions in the node network, validate these transactions and generate new blocks. Blocks are, in turn, distributed and validated by network nodes. The distributed ledger is kept synchronized for all nodes in a network. If conflicts occur, nodes agree upon which block chains are considered valid and rollback the invalid block chains.

    - Transactions layer

        Transactions that are basis for block generation and blockchain protocol itself are a result of actions performed at the top layer. As explained in :ref:`implementation`, transactions are automatically generated by |platform| frontend, Molis client. 

        When a user or a developer makes an action such as clicking a button on a page or executing a contract from the code editor, Molis converts this action into a transaction and sends it to the network node that it is connected to. 


Thus, the top layer is connected to the bottom layer and the transaction flow goes in the opposite direction: 

    - A user action in an app creates a transaction.

    - The transaction gets included in a block.

    - The block is included in the blockchain.

    - Changes in the blockchain cause changes in the global state, the action is applied to the database.

    - The database changes are displayed in the app.


.. _implementation:

The implementation
------------------

.. todo::

    When detailed docs about implementation (daemons) are ready, link them here and to the blockchain chapter below. 


Two main components of |platform| are its backend, |backend_gh|, and Molis client, |frontend_gh|.


Molis client: 

    - Provides a user interface for |platform|.

    - Provides an IDE for app development.

    - Sends transactions to the backend via :doc:`REST API</reference/api2>`. 

        Transactions are created automatically for user actions that require a transaction. For example, when an app developer executes a contract from the IDE, Molis converts this action into a transaction.


The backend: 

    - Keeps the global state (the database) of the node.
    - Implements all |platform| blockchain protocols.
    - Implements :doc:`REST API</reference/api2>`.
